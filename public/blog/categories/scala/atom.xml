<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Dao De Code]]></title>
  <link href="http://daodecode.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://daodecode.com/"/>
  <updated>2014-10-27T17:20:31-04:00</updated>
  <id>http://daodecode.com/</id>
  <author>
    <name><![CDATA[Eugene Platonov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[scala-maven-plugin and Multiple versions of scala libraries detected]]></title>
    <link href="http://daodecode.com/blog/2014/10/27/scala-maven-plugin-and-multiple-versions-of-scala-libraries-detected/"/>
    <updated>2014-10-27T17:15:00-04:00</updated>
    <id>http://daodecode.com/blog/2014/10/27/scala-maven-plugin-and-multiple-versions-of-scala-libraries-detected</id>
    <content type="html"><![CDATA[<p>Have you ever seen messages like these running <a href="https://github.com/davidB/scala-maven-plugin">scala-maven-plugin</a>?
<code>
[WARNING]  Expected all dependencies to require Scala version: 2.10.3
[WARNING]  mycoolcompany:mycoolproject:1.5.25 requires scala version: 2.10.3
[WARNING]  me.lessis:odelay-core_2.10:0.1.0 requires scala version: 2.10.4
[WARNING] Multiple versions of scala libraries detected!
</code></p>

<p>Starting from scala 2.10 all changes in <a href="http://semver.org/">bugfix/patch</a> version should be backward compatible,
so these warnings don't really have the point in this case.
But they are still very important in case when, let's say, you somehow end up with scala 2.9 and 2.11 libraries.
It happens that since version 3.1.6 you can fix this using <code>scalaCompatVersion</code> configuration</p>

<p>``` xml</p>

<pre><code>        &lt;plugin&gt;
            &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;
            &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1.6&lt;/version&gt;
            &lt;configuration&gt;
                &lt;scalaCompatVersion&gt;${scala.binary.version}&lt;/scalaCompatVersion&gt;
                &lt;scalaVersion&gt;${scala.version}&lt;/scalaVersion&gt;
            &lt;/configuration&gt;
            &lt;!-- other settings--&gt;
        &lt;/plugin&gt;
</code></pre>

<p>```</p>

<p>Where in my case I have <code>scala.binary.version</code> property defined as</p>

<p><code>xml
&lt;scala.binary.version&gt;2.10&lt;/scala.binary.version&gt;
</code>
No more meaningless warnings!</p>

<p><a href="https://groups.google.com/forum/#!topic/maven-and-scala/XSkXrSS8WuU">Related discussions on google groups</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Call Scala curried functions from Java]]></title>
    <link href="http://daodecode.com/blog/2014/04/29/call-scala-curried-functions-from-java/"/>
    <updated>2014-04-29T13:40:00-04:00</updated>
    <id>http://daodecode.com/blog/2014/04/29/call-scala-curried-functions-from-java</id>
    <content type="html"><![CDATA[<p>For some reason I thought scala curried functions is one of the features you will have troubles using from Java. But it happens that you can perfectly call a curried Scala function</p>

<p>``` scala
class A {</p>

<pre><code>def curried(i: Int)(s: String) = i + s.toInt
</code></pre>

<p>}
```
from Java</p>

<p>``` java
new A().curried(5, "7")</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sbt Plugins: No Default Package Please]]></title>
    <link href="http://daodecode.com/blog/2014/02/18/sbt-plugins-no-default-package-please/"/>
    <updated>2014-02-18T16:46:00-05:00</updated>
    <id>http://daodecode.com/blog/2014/02/18/sbt-plugins-no-default-package-please</id>
    <content type="html"><![CDATA[<p>Usually people don't put sbt builds in a package (I'm talking about scala files here), especially for simple and small projects.
And they easily can use all the sbt plugins. <br/>
But there are other users who have bigger and more complex builds.
So they put their builds in packages and then they discover they can use only plugins which themselves defined in packages. Bummer!</p>

<p>Scala, as well as Java, does allow classes in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.4.2">default or unnamed</a> package, but those classes can be accessed within default package only.
There is literally <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.5">no way</a> to import a class from default package.
Thus when someone creates an sbt plugin and puts it in default package, (s)he makes owners of packaged builds
 feel almost physical pain when they try to use the plugin.</p>

<p>So if you are an author of an sbt plugin, please consider to put it into a package. Doing otherwise violates
<a href="https://github.com/sbt/sbt/blob/0.13/src/sphinx/Extending/Plugins-Best-Practices.rst#dont-use-default-package">best practices</a>
 and makes God to kill a kitten.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Override a list property for Typesafe Config]]></title>
    <link href="http://daodecode.com/blog/2014/02/04/override-a-list-property-for-typesafe-config/"/>
    <updated>2014-02-04T19:39:00-05:00</updated>
    <id>http://daodecode.com/blog/2014/02/04/override-a-list-property-for-typesafe-config</id>
    <content type="html"><![CDATA[<p>Today I naively was trying to override a list property for a unit test with the following code
<code>scala
System.setProperty("list.property", """[ "val1", "val2"]""")
</code></p>

<p>The tested code is reading the list property using <a href="https://github.com/typesafehub/config">typesafe config</a> library</p>

<p><code>scala
val listProperty = config.getListString.asScala.toSet
</code></p>

<p>That was throwing
<code>com.typesafe.config.ConfigException$WrongType: system properties: list.property has type STRING rather than LIST</code></p>

<p>so I've googled a <a href="https://github.com/typesafehub/config/issues/69">solution</a> for overriding list properties from
command line, which is same for overriding in code</p>

<p>Here is how it looks now</p>

<p><code>scala
System.setProperty("list.property.0", "val1")
System.setProperty("list.property.1", "val2")
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveMongo, macros and  NoSuchElementException: None.get]]></title>
    <link href="http://daodecode.com/blog/2013/10/27/reactivemongo-macros-and-nosuchelementexception-none-get/"/>
    <updated>2013-10-27T20:40:00-04:00</updated>
    <id>http://daodecode.com/blog/2013/10/27/reactivemongo-macros-and-nosuchelementexception-none-get</id>
    <content type="html"><![CDATA[<p><a href="http://reactivemongo.org/">ReactiveMongo</a> employs <a href="http://scalamacros.org/">scala macros</a>
 to generate readers(deserializers) and writers(serializers)
for scala case classes. They work pretty good, but sometimes you can get a
<code>java.lang.NoSuchElementException</code> with message <code>None.get</code> :(</p>

<p>Let's say you have
``` scala
case class Person(fisrtName: String, lastName: String, age: Int)</p>

<p>object readers {
  implicit val personReader = Macros.reader[Person]
}</p>

<p>```</p>

<p>and somewhere in your code you use it
<code>scala
import readers._
// ...
def findByFirstName(fName: String) =
  personCollection.find(BSONDocument("firstName" -&gt; fName)).one[Person]
</code></p>

<p>if your data is correct you are good, but let's say you have some corrupted documents, for example <code>Joe</code> doesn't have last name
```</p>

<blockquote><p>db.person.find().pretty()
{</p>

<pre><code>"_id" : ObjectId("526ecf6f7e04ab5f2d1a12ba"),
"firstName" : "Eugene",
"lastName" : "Platonov",
"age" : 27
</code></pre>

<p>}
{</p>

<pre><code>"_id" : ObjectId("526ecf817e04ab5f2d1a12bb"),
"firstName" : "Joe",
"age" : 23
</code></pre>

<p>}
```</p></blockquote>

<p><code>findByFirstName("Eugene")</code> will return Future of Success, but <code>findByFirstName("Joe")</code>
will return you Future of Failure with ugly <code>java.util.NoSuchElementException: None.get</code> which
points to the line where your macro-generated reader is defined.</p>

<p>Here is another, even more interesting, but much harder to spot problem:</p>

<p>If you insert your person doc via mongo shell</p>

<p><code>
 db.person.insert({firstName: "Eugene", lastName: "Platonov", age: 27})
</code>
the type of <code>age</code> field will be ... right, <a href="http://docs.mongodb.org/manual/core/shell-types/">Double</a>.
Despite that mongo shell will show you <code>"age" : 27</code> when you search for that document.
And again reactivemongo will throw a <code>NoSuchElementException</code> exception at you. Sigh.</p>

<p>To avoid it insert integers as <code>NumberInt</code>s</p>

<p><code>
db.person.insert({firstName: "Eugene", lastName: "Platonov", age: NumberInt(27)})
</code></p>

<p>I think reactive mongo should be more explicit about what went wrong and hopefully
this will be <a href="https://github.com/ReactiveMongo/ReactiveMongo/pull/131">fixed soon</a>, but if not, you know where the dog lies buried.</p>
]]></content>
  </entry>
  
</feed>
