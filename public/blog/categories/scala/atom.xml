<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Dao De Code]]></title>
  <link href="http://daodecode.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://daodecode.com/"/>
  <updated>2013-04-19T22:02:24-04:00</updated>
  <id>http://daodecode.com/</id>
  <author>
    <name><![CDATA[Eugene Platonov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debug an sbt plugin in IntelliJ IDEA]]></title>
    <link href="http://daodecode.com/blog/2013/04/19/debug-an-sbt-plugin-in-intellij-idea/"/>
    <updated>2013-04-19T12:51:00-04:00</updated>
    <id>http://daodecode.com/blog/2013/04/19/debug-an-sbt-plugin-in-intellij-idea</id>
    <content type="html"><![CDATA[<p>So you have your own sbt plugin (or someone's plugin if you are not so cool and sexy) and you want to debug it.
It happens that there is nothing easier than that. If you run sbt through <a href="https://github.com/paulp/sbt-extras">sbt-extras</a> script (if you don't you should)
just start your test sbt app with the plugin added to the build with the following command
<code>
sbt -jvm-debug 5005
</code></p>

<p>You can use any port, I use 5005 because it's a default port for remote debug configuration in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> which I use for scala development.
And if you are cool and sexy, you know... :)</p>

<p>This is how your sbt console should look like after you start it:
```
jozic@laptop ~/projects/sbt-about-plugins $ sbt -jvm-debug 5005
Detected sbt version 0.12.3
Starting sbt: invoke with -help for other options
Listening for transport dt_socket at address: 5005
[info] Loading global plugins from /home/jozic/.sbt/plugins
[info] Loading project definition from /home/jozic/projects/sbt-about-plugins/project
[info] Set current project to sbt-about-plugins (in build file:/home/jozic/projects/sbt-about-plugins/)</p>

<blockquote><p>```</p></blockquote>

<p>Then open your project in IDEA (you can generate IDEA project files using
<a href="https://github.com/mpeltonen/sbt-idea">sbt-idea</a> plugin) and create remote debug configuration.
<img src="/images/sbt-debug/idea.debug.configuration.png">
You can change port, but 5005 will do in our case, so you literaly can save default configuration.
Run it and you should get the following line in IDEA console:
<code>
Connected to the target VM, address: 'localhost:5005', transport: 'socket'
</code></p>

<p>After that put a breakpoint inside your plugin command, switch to sbt console, run your command and here you go!
<img src="/images/sbt-debug/idea.breakpoint.in.action.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Security.Authenticated in Play 2.0 and 2.1]]></title>
    <link href="http://daodecode.com/blog/2013/03/08/testing-security-dot-authenticated-in-play-2-dot-0-and-2-dot-1/"/>
    <updated>2013-03-08T21:00:00-05:00</updated>
    <id>http://daodecode.com/blog/2013/03/08/testing-security-dot-authenticated-in-play-2-dot-0-and-2-dot-1</id>
    <content type="html"><![CDATA[<p>You have a <a href="http://www.playframework.com/">Play</a> application and let's say you want to add some simple authentication logic to restrict access to your actions.
You want all your users to provide a ticket (e.g <a href="https://wiki.jasig.org/display/CAS/Proxy+CAS+Walkthrough">cas proxy ticket</a>)
in a request header, so you can use the ticket to authenticate them.</p>

<p>Play's <a href="http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.mvc.Security$">Security.Authenticated</a>
to the rescue!</p>

<p>You can come up with something like this in Play 2.1:</p>

<p>``` scala
trait Secured {</p>

<p>  val logger = Logger("secured")</p>

<p>  final def fail(reason: String) = {</p>

<pre><code>logger.debug(s"Access attempt failed: $reason")
Unauthorized("must be authenticated")
</code></pre>

<p>  }</p>

<p>  final def secured<a href="action:%20Action[A]">A</a> =</p>

<pre><code>Security.Authenticated(
  req =&gt; req.headers.get("authTicket"),
  _ =&gt; fail("no ticket found")) {
  ticket =&gt; Action(action.parser) {
    request =&gt; withTicket(ticket) {
      action(request)
    }
  }
}
</code></pre>

<p>  private def withTicket(ticket: String)(produceResult: => Result): Result =</p>

<pre><code>Async {
  isValid(ticket) map {
    valid =&gt; if (valid) produceResult else fail(s"provided ticket $ticket is invalid")
  }
}
</code></pre>

<p>  def isValid(ticket: String): Future[Boolean]
}
<code>``
In Play 2.0 it looks almost same except that</code>isValid<code>returns _old_ play's</code>Promise<code>instead of scala's</code>Future`.</p>

<p>And you can use it like this:</p>

<p>``` scala</p>

<pre><code>def securedAction = secured {
  Action {
    request =&gt; Ok("Am I protected?")
  }
}
</code></pre>

<p>```</p>

<p>All good, but how do we know it works? Test it!</p>

<p>Let's create a fake controller which has both secured and non-secured actions. And we'll use it in our tests, or rather <a href="http://etorreborre.github.com/specs2/">specs</a>.</p>

<p>``` scala
  object FakeController extends Controller with Secured {</p>

<pre><code>def securedAction = secured {
  Action {
    request =&gt; Ok("Am I protected?")
  }
}

def nonSecuredAction = Action {
  request =&gt; Ok("I don't care")
}

def isValid(ticket: String) = Promise.pure(ticket == "valid")
</code></pre>

<p>  }
```</p>

<p>To test that <code>authTicket</code> param is required we can have something like this:</p>

<p>``` scala</p>

<pre><code>"return UNAUTHORIZED if `authTicket` param is not provided" in {
  running(app) {
    val result = FakeController.securedAction process FakeRequest()
    status(result) must_== UNAUTHORIZED
    contentAsString(result) must_== "must be authenticated"
  }
}
</code></pre>

<p>```</p>

<p>Here <code>app</code> is a <a href="http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.test.FakeApplication">FakeApplication</a>
 and <code>process</code> is our method (added through implicits) which returns a <a href="http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.mvc.Result">Result</a>
  given a <a href="http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.mvc.Request">Request</a>.</p>

<p>Please note in Play 2.0 <code>status</code> and <code>contentAsString</code> don't know how to handle <a href="http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.mvc.AsyncResult">AsyncResults</a>,
so with this implementation of <code>withTicket</code> you need to do some trible dance to make it work.</p>

<p>In Play 2.0 <code>Authenticated</code> returnes <code>Action[(Action[A], A)]</code> so our <code>process</code> looks like this:</p>

<p>``` scala
  implicit def action2actionExecutor<a href="wrapped:%20Action[(Action[A],%20A">A</a>]): ActionExecutor[A]
  = new ActionExecutor<a href="wrapped">A</a></p>

<p>  class ActionExecutor<a href="wrapped:%20Action[(Action[A],%20A">A</a>]) {</p>

<pre><code>def process(request: Request[A]): Result = wrapped.parser(request).run.await.get match {
  case Left(errorResult) =&gt; errorResult
  case Right((innerAction, _)) =&gt; innerAction(request)
}
</code></pre>

<p>  }
```</p>

<p>in Play 2.1 we get just <a href="">EssentialAction</a> (and we can use <a href="">implicit class</a>) so it looks much simple:</p>

<p>``` scala
  implicit class ActionExecutor(action: EssentialAction) {</p>

<pre><code>def process[A](request: Request[A]): Result =
  concurrent.Await.result(action(request).run, Duration(1, "sec"))
</code></pre>

<p>  }
```</p>

<p>To test what happens if <code>authTicket</code> is provided but is not valid we can do the following:</p>

<p>``` scala</p>

<pre><code>def requestWithAuthTicket(ticket: String = "invalid") =
  FakeRequest().withHeaders("authTicket" -&gt; ticket)

"return UNAUTHORIZED if `authTicket` param is not valid" in {
  running(app) {
    val result = FakeController.securedAction process requestWithAuthTicket()
    status(result) must_== UNAUTHORIZED
    contentAsString(result) must_== "must be authenticated"
  }
}
</code></pre>

<p>```
To make sure that it allows access when ticket is valid let's add this</p>

<p>``` scala</p>

<pre><code>"return whatever it returns if `authTicket` param is valid" in {
  running(app) {
    val result = FakeController.securedAction process requestWithAuthTicket(ticket = "valid")
    status(result) must_== OK
    contentAsString(result) must_== "Am I protected?"
  }
}
</code></pre>

<p>```</p>

<p>Full source code can be found on <a href="https://github.com/jozic/play-security-authenticated-tests">github</a> in branches play20 and play20 correspondently.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Camel and Scala 2.10]]></title>
    <link href="http://daodecode.com/blog/2013/02/28/camel-and-scala-2-dot-10/"/>
    <updated>2013-02-28T23:33:00-05:00</updated>
    <id>http://daodecode.com/blog/2013/02/28/camel-and-scala-2-dot-10</id>
    <content type="html"><![CDATA[<p><a href="http://camel.apache.org/">Camel</a> and <a href="http://www.scala-lang.org/">Scala</a> is a good combination,
but if you like to be on the bleeding edge and almost done converting your scala app to <a href="http://www.scala-lang.org/node/27499">2.10</a>
you can find that camel still doesn't have a stable release supporting scala 2.10.
So SNAPSHOT will do the trick in this case, but you know... it's a SNAPSHOT :)<br/>
All you need is apache snapshots repo and camel-scala 2.11-SNAPSHOT</p>

<p>``` scala
resolvers += "Apache Snapshots" at "http://repository.apache.org/snapshots/"</p>

<p>libraryDependencies += "org.apache.camel" % "camel-scala" % "2.11-SNAPSHOT"
```
Add those to your sbt build and you are all set.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Root Application Context in Play 2.1]]></title>
    <link href="http://daodecode.com/blog/2013/02/23/root-application-context-in-play-2-dot-1/"/>
    <updated>2013-02-23T17:34:00-05:00</updated>
    <id>http://daodecode.com/blog/2013/02/23/root-application-context-in-play-2-dot-1</id>
    <content type="html"><![CDATA[<p>So <a href="http://www.playframework.com/">Play 2.1</a> is officialy out and one of the new features it brings is the ability
to configure root application context. It have been in <a href="https://github.com/playframework/Play20/commit/da6bbc4">2.1 branch</a>
 for a long-long time and I don't see this mentioned in
<a href="http://www.playframework.com/documentation/2.1.0/Highlights">highlights section</a>, but nevertheless it's there and it works.
To assign a root context to your play app just open your <code>application.conf</code> file and add the following line
<code>
application.context=/my_root_context
</code>
Make sure you have it starting with slash (<code>/</code>)
otherwise play will throw a configuration error at you saying "Invalid application context".</p>
]]></content>
  </entry>
  
</feed>
