<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Dao De Code]]></title>
  <link href="http://daodecode.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://daodecode.com/"/>
  <updated>2014-09-06T20:50:59-04:00</updated>
  <id>http://daodecode.com/</id>
  <author>
    <name><![CDATA[Eugene Platonov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Call Scala curried functions from Java]]></title>
    <link href="http://daodecode.com/blog/2014/04/29/call-scala-curried-functions-from-java/"/>
    <updated>2014-04-29T13:40:00-04:00</updated>
    <id>http://daodecode.com/blog/2014/04/29/call-scala-curried-functions-from-java</id>
    <content type="html"><![CDATA[<p>For some reason I thought scala curried functions is one of the features you will have troubles using from Java. But it happens that you can perfectly call a curried Scala function</p>

<p>``` scala
class A {</p>

<pre><code>def curried(i: Int)(s: String) = i + s.toInt
</code></pre>

<p>}
```
from Java</p>

<p>``` java
new A().curried(5, "7")</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sbt Plugins: No Default Package Please]]></title>
    <link href="http://daodecode.com/blog/2014/02/18/sbt-plugins-no-default-package-please/"/>
    <updated>2014-02-18T16:46:00-05:00</updated>
    <id>http://daodecode.com/blog/2014/02/18/sbt-plugins-no-default-package-please</id>
    <content type="html"><![CDATA[<p>Usually people don't put sbt builds in a package (I'm talking about scala files here), especially for simple and small projects.
And they easily can use all the sbt plugins. <br/>
But there are other users who have bigger and more complex builds.
So they put their builds in packages and then they discover they can use only plugins which themselves defined in packages. Bummer!</p>

<p>Scala, as well as Java, does allow classes in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.4.2">default or unnamed</a> package, but those classes can be accessed within default package only.
There is literally <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.5">no way</a> to import a class from default package.
Thus when someone creates an sbt plugin and puts it in default package, (s)he makes owners of packaged builds
 feel almost physical pain when they try to use the plugin.</p>

<p>So if you are an author of an sbt plugin, please consider to put it into a package. Doing otherwise violates
<a href="https://github.com/sbt/sbt/blob/0.13/src/sphinx/Extending/Plugins-Best-Practices.rst#dont-use-default-package">best practices</a>
 and makes God to kill a kitten.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Override a list property for Typesafe Config]]></title>
    <link href="http://daodecode.com/blog/2014/02/04/override-a-list-property-for-typesafe-config/"/>
    <updated>2014-02-04T19:39:00-05:00</updated>
    <id>http://daodecode.com/blog/2014/02/04/override-a-list-property-for-typesafe-config</id>
    <content type="html"><![CDATA[<p>Today I naively was trying to override a list property for a unit test with the following code
<code>scala
System.setProperty("list.property", """[ "val1", "val2"]""")
</code></p>

<p>The tested code is reading the list property using <a href="https://github.com/typesafehub/config">typesafe config</a> library</p>

<p><code>scala
val listProperty = config.getListString.asScala.toSet
</code></p>

<p>That was throwing
<code>com.typesafe.config.ConfigException$WrongType: system properties: list.property has type STRING rather than LIST</code></p>

<p>so I've googled a <a href="https://github.com/typesafehub/config/issues/69">solution</a> for overriding list properties from
command line, which is same for overriding in code</p>

<p>Here is how it looks now</p>

<p><code>scala
System.setProperty("list.property.0", "val1")
System.setProperty("list.property.1", "val2")
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveMongo, macros and  NoSuchElementException: None.get]]></title>
    <link href="http://daodecode.com/blog/2013/10/27/reactivemongo-macros-and-nosuchelementexception-none-get/"/>
    <updated>2013-10-27T20:40:00-04:00</updated>
    <id>http://daodecode.com/blog/2013/10/27/reactivemongo-macros-and-nosuchelementexception-none-get</id>
    <content type="html"><![CDATA[<p><a href="http://reactivemongo.org/">ReactiveMongo</a> employs <a href="http://scalamacros.org/">scala macros</a>
 to generate readers(deserializers) and writers(serializers)
for scala case classes. They work pretty good, but sometimes you can get a
<code>java.lang.NoSuchElementException</code> with message <code>None.get</code> :(</p>

<p>Let's say you have
``` scala
case class Person(fisrtName: String, lastName: String, age: Int)</p>

<p>object readers {
  implicit val personReader = Macros.reader[Person]
}</p>

<p>```</p>

<p>and somewhere in your code you use it
<code>scala
import readers._
// ...
def findByFirstName(fName: String) =
  personCollection.find(BSONDocument("firstName" -&gt; fName)).one[Person]
</code></p>

<p>if your data is correct you are good, but let's say you have some corrupted documents, for example <code>Joe</code> doesn't have last name
```</p>

<blockquote><p>db.person.find().pretty()
{</p>

<pre><code>"_id" : ObjectId("526ecf6f7e04ab5f2d1a12ba"),
"firstName" : "Eugene",
"lastName" : "Platonov",
"age" : 27
</code></pre>

<p>}
{</p>

<pre><code>"_id" : ObjectId("526ecf817e04ab5f2d1a12bb"),
"firstName" : "Joe",
"age" : 23
</code></pre>

<p>}
```</p></blockquote>

<p><code>findByFirstName("Eugene")</code> will return Future of Success, but <code>findByFirstName("Joe")</code>
will return you Future of Failure with ugly <code>java.util.NoSuchElementException: None.get</code> which
points to the line where your macro-generated reader is defined.</p>

<p>Here is another, even more interesting, but much harder to spot problem:</p>

<p>If you insert your person doc via mongo shell</p>

<p><code>
 db.person.insert({firstName: "Eugene", lastName: "Platonov", age: 27})
</code>
the type of <code>age</code> field will be ... right, <a href="http://docs.mongodb.org/manual/core/shell-types/">Double</a>.
Despite that mongo shell will show you <code>"age" : 27</code> when you search for that document.
And again reactivemongo will throw a <code>NoSuchElementException</code> exception at you. Sigh.</p>

<p>To avoid it insert integers as <code>NumberInt</code>s</p>

<p><code>
db.person.insert({firstName: "Eugene", lastName: "Platonov", age: NumberInt(27)})
</code></p>

<p>I think reactive mongo should be more explicit about what went wrong and hopefully
this will be <a href="https://github.com/ReactiveMongo/ReactiveMongo/pull/131">fixed soon</a>, but if not, you know where the dog lies buried.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Akka: Stop Your Router Gracefully]]></title>
    <link href="http://daodecode.com/blog/2013/07/12/akka-stop-your-router-gracefully/"/>
    <updated>2013-07-12T23:34:00-04:00</updated>
    <id>http://daodecode.com/blog/2013/07/12/akka-stop-your-router-gracefully</id>
    <content type="html"><![CDATA[<p>Let's say you want to find an answer to <a href="http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything">Life, the Universe and Everything</a>
 and you know it will take some time,
 so you want to do it in parralel while doing something else (DSE).<br/>
You say to yourself "okay, I'll fire an actor and send him a message or bunch of messages, then DSE and collect my results from the actor after i'm done"</p>

<p>So you've got it coded
``` scala
  val answerToLifeTheUniverseAndEverything = new AtomicInteger(0)</p>

<p>  val actor = system.actorOf(Props(new Actor {</p>

<pre><code>def receive = {
  case i: Int =&gt; {
    answerToLifeTheUniverseAndEverything.getAndIncrement()
  }
  case _ =&gt;
}
</code></pre>

<p>  }))
```</p>

<p>Now you want make it work and get results at the end. You need to make sure to access the result after all work is done.
From <a href="http://akka.io/docs/">akka documentation</a> you found out that <a href="http://doc.akka.io/api/akka/2.2.0/index.html#akka.pattern.GracefulStopSupport"><code>akka.pattern.GracefulStopSupport</code></a>
seems a good choice to do it.</p>

<p>```
  for (i &lt;- 1 to 42) actor ! i</p>

<p>  // DO SOMETHING ELSE</p>

<p>  import akka.pattern.gracefulStop</p>

<p>  Await.result(gracefulStop(actor, timeout), timeout)</p>

<p>  println(s"We found the answer, it's ${answerToLifeTheUniverseAndEverything.get}")</p>

<p><code>
as a result you see
</code>
We found the answer, it's 42
```
Nice!<br/>
But then you think "I can do it not only in parallel to my DSE, but compute it in many independent actors, so it will be done even faster".
Using a router actor seems an easy way to do it.</p>

<p>```
  val answerToLifeTheUniverseAndEverything = new AtomicInteger(0)</p>

<p>  val router = system.actorOf(Props(new Actor {</p>

<pre><code>def receive = {
  case i: Int =&gt; {
    answerToLifeTheUniverseAndEverything.getAndIncrement()
  }
  case _ =&gt;
}
</code></pre>

<p>  }).withRouter(RoundRobinRouter(nrOfInstances = 10)))</p>

<p>  for (i &lt;- 1 to 42) router ! i</p>

<p>  // DO SOMETHING ELSE</p>

<p>  import akka.pattern.gracefulStop</p>

<p>  Await.result(gracefulStop(router, timeout), timeout)</p>

<p>  println(s"We found the answer, it's ${answerToLifeTheUniverseAndEverything.get}")
```</p>

<p>Router sends messages to routees in round-robin fashion and routees do the work parallel to each other.
At the end you again see
<code>
We found the answer, it's 42
</code></p>

<p>Super nice! You're done! You can go and grab a milk shake. Or do you?  <br/>
Computing answer to Life, the Universe and Everything is a complex task, so it really should take some time and effort to calculate it.<br/>
Let's add <code>Thread.sleep(1000)</code> pretending that our actor(or rather many actors) do something time consuming.
```</p>

<pre><code>def receive = {
  case i: Int =&gt; {
    Thread.sleep(1000)
    answerToLifeTheUniverseAndEverything.getAndIncrement()
  }
  case _ =&gt;
}
</code></pre>

<p><code>
And then while you enjoing your shake all of a sudden you see
</code>
We found the answer, it's 10
<code>``
What the hell?  
The thing is</code>gracefullStop<code>sends a</code>PoisonPill<code>to an actor, which is a router in our case.
Once an actor gets to a</code>PoisonPill<code>message it decides to die and as a good parent, he can't allow his children stay and suffer in this cruel world, so he kills them too.  
"But</code>PoisonPill` will be the last message my router gets, right? So it dies after all other messages are processed." you say.<br/>
Right, but processing a message from a router's point of view is just to send it to one of its routees.<br/>
But then it dies when they still in progress and because the number of messages (42) is greater than number of routees (10) they all have more than one message to process.
So they do, until their <em>Daddy</em> comes and gets them to the <em>Land of Peace</em>. Their unprocessed messages are lost.
Thus the answer to Life, the Universe and Everything you get is 10. It can be different, but it usually will be around a number of routees.</p>

<p>So what is the solution?</p>

<p>The answer before akka 2.2 is don't use <code>gracefulStop</code> with routers! (Of course you can take a look at the source code and make your own version of <code>gracefulStop</code>)
Since 2.2 you can specify stopMessage which is a <code>PoisonPill</code> by default. So the line will look like</p>

<p><code>
  Await.result(gracefulStop(router, timeout, Broadcast(PoisonPill)), timeout)
</code>
And now the answer is correct again :)
<code>
We found the answer, it's 42
</code></p>
]]></content>
  </entry>
  
</feed>
